// BULLMONEY MEMORY GUARDIAN v5.0 (auto-generated by boost.py)
// Prevents crashes & slowdowns on low-memory devices, in-app browsers, and heavy pages
// v5.0: Proactive cleanup — intervals, timers, AudioContexts, detached DOM, history cap
(function(){
'use strict';
var w=window,d=document,n=navigator,p=performance;
var MG=w.__BM_MEMORY_GUARDIAN__={active:true,level:'normal',disposals:0,gcTriggers:0,version:'4.0'};

// ─── 131. Memory Pressure Detection ───
var memInfo={limit:0,used:0,pct:0};
function updateMemInfo(){
  if(p.memory){
    memInfo.used=p.memory.usedJSHeapSize;
    memInfo.limit=p.memory.jsHeapSizeLimit;
    memInfo.pct=Math.round((memInfo.used/memInfo.limit)*100);
    MG.heap={usedMB:Math.round(memInfo.used/1048576),limitMB:Math.round(memInfo.limit/1048576),pct:memInfo.pct};
  }
  // Safari/WebKit fallback: no p.memory, estimate from DOM + listener count
  if(!p.memory){
    var domEst=(MG.domNodes||0)*0.002; // ~2KB per node
    var listenerEst=(MG.eventListeners||0)*0.001;
    memInfo.used=(domEst+listenerEst)*1048576;
    memInfo.limit=budgetMB*1048576;
    memInfo.pct=Math.min(100,Math.round((memInfo.used/memInfo.limit)*100));
    MG.heap={usedMB:Math.round(domEst+listenerEst),limitMB:budgetMB,pct:memInfo.pct,estimated:true};
  }
}

// ─── 132. Device Memory Budget Calculator ───
var deviceMem=n.deviceMemory||4;
// Detect in-app browsers — they get much tighter budgets
var ua=n.userAgent||'';
var isInApp=/instagram|fban|fbav|tiktok|snapchat|twitter|linkedin|wechat|line\/|telegram|pinterest|reddit/i.test(ua);
var isSafari=/^((?!chrome|android).)*safari/i.test(ua);
var isMobile=/mobi|android|iphone|ipad|ipod/i.test(ua);
MG.isInApp=isInApp;MG.isSafari=isSafari;MG.isMobile=isMobile;

var budgetMB=(function(){
  // In-app browsers are severely memory-constrained
  if(isInApp){
    if(deviceMem>=4)return 100;
    if(deviceMem>=2)return 60;
    return 40;
  }
  if(isMobile){
    if(deviceMem>=8)return 250;
    if(deviceMem>=6)return 200;
    if(deviceMem>=4)return 150;
    if(deviceMem>=2)return 80;
    return 50;
  }
  if(deviceMem>=8)return 350;
  if(deviceMem>=6)return 250;
  if(deviceMem>=4)return 180;
  if(deviceMem>=2)return 100;
  return 60;
})();
MG.budgetMB=budgetMB;

// ─── 133. Memory Level System ───
// normal → warning → critical → emergency
function updateMemoryLevel(){
  updateMemInfo();
  var pct=memInfo.pct;
  var used=memInfo.used/1048576;
  var prev=MG.level;

  if(pct>90||used>budgetMB*1.2){MG.level='emergency';}
  else if(pct>75||used>budgetMB){MG.level='critical';}
  else if(pct>60||used>budgetMB*0.8){MG.level='warning';}
  else{MG.level='normal';}

  if(MG.level!==prev){
    d.documentElement.setAttribute('data-memory-level',MG.level);
    w.dispatchEvent(new CustomEvent('bullmoney-memory-level',{detail:{level:MG.level,pct:pct,usedMB:Math.round(used),budgetMB:budgetMB}}));

    if(MG.level==='critical'||MG.level==='emergency'){
      executeMemoryRelief(MG.level);
    }
  }
}

// ─── 134. Automatic Memory Relief Actions ───
function executeMemoryRelief(level){
  MG.gcTriggers++;

  // Level 1: Dispose off-screen images and iframes
  if(level==='critical'||level==='emergency'){
    d.querySelectorAll('img[loading="lazy"]:not([data-in-view])').forEach(function(img){
      if(!isElementInView(img)){img.src='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';MG.disposals++;}
    });
    d.querySelectorAll('iframe:not([data-keep])').forEach(function(iframe){
      if(!isElementInView(iframe)){
        iframe.setAttribute('data-src-backup',iframe.src);
        iframe.src='about:blank';
        MG.disposals++;
      }
    });
    // Kill stale timers (v5.0)
    if(typeof pruneStaleTimers==='function')pruneStaleTimers(level==='emergency'?0.5:0.7);
    // Close leaked AudioContexts (v5.0)
    if(typeof reapAudioContexts==='function')reapAudioContexts();
  }

  // Level 2: Reduce 3D quality but keep scenes visible (never hide)
  if(level==='emergency'){
    w.dispatchEvent(new CustomEvent('bullmoney-3d-quality-change',{detail:{quality:'low',fps:0}}));
    d.documentElement.classList.add('memory-emergency');
    d.documentElement.style.setProperty('--animation-duration','0.01s');
    d.documentElement.style.setProperty('--transition-speed','0.01s');
    d.documentElement.style.setProperty('--blur-amount','0px');
    if(w.__BM_SPLINE_TURBO__){
      w.__BM_SPLINE_TURBO__.quality='low';
      d.documentElement.setAttribute('data-3d-quality','low');
    }
    try{if(w.gc)w.gc();}catch(e){}
    d.querySelectorAll('video[autoplay]').forEach(function(v){
      v.pause();v.preload='none';
      v.setAttribute('data-low-mem-paused','1');
    });
    // Emergency: nuke detached DOM nodes (v5.0)
    if(typeof sweepDetachedNodes==='function')sweepDetachedNodes();
    // Emergency: clear all non-essential caches (v5.0)
    if(typeof clearInternalCaches==='function')clearInternalCaches();
  }

  if(w.location.hostname==='localhost'){
    console.warn('[MEMORY GUARDIAN v4] '+level+' relief executed. Disposed: '+MG.disposals+' elements');
  }
}

function isElementInView(el){
  var r=el.getBoundingClientRect();
  return r.bottom>-200&&r.top<(w.innerHeight+200);
}

// ─── 135. Periodic Memory Monitoring ───
var checkInterval=isInApp?1500:deviceMem>=8?10000:deviceMem>=4?5000:isMobile?2500:3000;
setInterval(updateMemoryLevel,checkInterval);
updateMemoryLevel();

// ─── 136. DOM Node Counter (detect leaks) ───
var lastNodeCount=0;
var nodeGrowthWarnings=0;
var DOM_NODE_HARD_CAP=isInApp?4000:isMobile?6000:10000;
setInterval(function(){
  var count=d.querySelectorAll('*').length;
  MG.domNodes=count;
  // Hard cap: if DOM is absurdly large, force cleanup
  if(count>DOM_NODE_HARD_CAP){
    if(w.location.hostname==='localhost'){
      console.warn('[MEMORY GUARDIAN v4] DOM node hard cap exceeded: '+count+'/'+DOM_NODE_HARD_CAP+'. Running deep clean.');
    }
    if(typeof deepClean==='function')deepClean('dom-cap');
  }
  if(count>lastNodeCount+500&&lastNodeCount>0){
    nodeGrowthWarnings++;
    if(nodeGrowthWarnings>=3){
      w.dispatchEvent(new CustomEvent('bullmoney-dom-leak',{detail:{nodes:count,growth:count-lastNodeCount}}));
      if(w.location.hostname==='localhost'){
        console.warn('[MEMORY GUARDIAN v4] Possible DOM leak: '+count+' nodes (+'+(count-lastNodeCount)+')');
      }
      // Proactive: run cleanup on repeated growth
      if(typeof deepClean==='function')deepClean('dom-growth');
      nodeGrowthWarnings=0;
    }
  } else {nodeGrowthWarnings=Math.max(0,nodeGrowthWarnings-1);}
  lastNodeCount=count;
},isInApp?8000:15000);

// ─── 137. Event Listener Leak Prevention ───
var listenerCount=0;
var LISTENER_CAP=isInApp?300:isMobile?500:1000;
var origAdd=EventTarget.prototype.addEventListener;
var origRemove=EventTarget.prototype.removeEventListener;
// Track per-element to detect duplicates
var listenerMap=new WeakMap();
EventTarget.prototype.addEventListener=function(type,fn,opts){
  listenerCount++;MG.eventListeners=listenerCount;
  // Track per element for duplicate detection
  var el=this;
  if(!listenerMap.has(el))listenerMap.set(el,[]);
  var list=listenerMap.get(el);
  // Prevent exact duplicate listeners (same type+fn) — common leak source
  for(var i=0;i<list.length;i++){
    if(list[i].type===type&&list[i].fn===fn){
      // Already registered, skip duplicate
      listenerCount--;MG.eventListeners=listenerCount;
      return;
    }
  }
  list.push({type:type,fn:fn});
  // Warn if approaching cap
  if(listenerCount>LISTENER_CAP&&listenerCount%100===0){
    if(w.location.hostname==='localhost'){
      console.warn('[MEMORY GUARDIAN v4] Listener count high: '+listenerCount+'/'+LISTENER_CAP);
    }
    if(listenerCount>LISTENER_CAP*1.5){
      // Over 1.5x cap: force cleanup
      if(typeof deepClean==='function')deepClean('listener-cap');
    }
  }
  return origAdd.call(this,type,fn,opts);
};
EventTarget.prototype.removeEventListener=function(type,fn,opts){
  listenerCount=Math.max(0,listenerCount-1);MG.eventListeners=listenerCount;
  if(listenerMap.has(this)){
    var list=listenerMap.get(this);
    for(var i=list.length-1;i>=0;i--){
      if(list[i].type===type&&list[i].fn===fn){list.splice(i,1);break;}
    }
  }
  return origRemove.call(this,type,fn,opts);
};

// ─── 138. Blob/ObjectURL Leak Prevention ───
var activeBlobs=new Set();
var origCreateURL=URL.createObjectURL;
var origRevokeURL=URL.revokeObjectURL;
URL.createObjectURL=function(blob){
  var url=origCreateURL.call(URL,blob);
  activeBlobs.add(url);MG.activeBlobs=activeBlobs.size;
  return url;
};
URL.revokeObjectURL=function(url){
  activeBlobs.delete(url);MG.activeBlobs=activeBlobs.size;
  return origRevokeURL.call(URL,url);
};
setInterval(function(){
  if(activeBlobs.size>50){
    var count=0;
    activeBlobs.forEach(function(url){
      if(count++<activeBlobs.size-20){
        try{origRevokeURL.call(URL,url);}catch(e){}
        activeBlobs.delete(url);
      }
    });
    MG.activeBlobs=activeBlobs.size;
  }
},60000);

// ─── 139. Scroll Performance Budget ───
var scrollJankCount=0;
var lastScrollTime=0;
w.addEventListener('scroll',function(){
  var now=p.now();
  if(lastScrollTime&&now-lastScrollTime>50){scrollJankCount++;}
  else{scrollJankCount=Math.max(0,scrollJankCount-1);}
  lastScrollTime=now;
  if(scrollJankCount>10){
    d.documentElement.classList.add('scroll-janky');
    scrollJankCount=0;
    // v5.0: If janky on mobile, force reduce effects
    if(isMobile||isInApp){
      d.documentElement.setAttribute('data-memory-level',
        MG.level==='normal'?'warning':MG.level);
    }
  }
},{passive:true});

// ─── 140. Component Disposal Queue ───
MG.disposalQueue=[];
MG.registerForDisposal=function(id,disposeFn,priority){
  MG.disposalQueue.push({id:id,dispose:disposeFn,priority:priority||5});
  MG.disposalQueue.sort(function(a,b){return b.priority-a.priority;});
};
MG.executeDisposalQueue=function(count){
  count=count||3;
  var disposed=MG.disposalQueue.splice(0,count);
  disposed.forEach(function(item){
    try{item.dispose();MG.disposals++;}catch(e){}
  });
  return disposed.length;
};
w.addEventListener('bullmoney-memory-level',function(e){
  if(e.detail.level==='critical')MG.executeDisposalQueue(3);
  if(e.detail.level==='emergency')MG.executeDisposalQueue(10);
});

// ─── 141-145. Memory-Aware CSS Injection (FULL EXPERIENCE - preserve colors) ───
// CRITICAL: Never strip `filter` — it controls invert/brightness/contrast for theming.
// Stripping filter causes black↔white color inversion glitches on dark theme.
// Only strip backdrop-filter (expensive GPU composite) with OPAQUE fallback backgrounds.
var memStyle=d.createElement('style');
memStyle.textContent=[
  // === WARNING LEVEL: remove backdrop blur only, preserve existing backgrounds ===
  '[data-memory-level="warning"] *{backdrop-filter:none!important;-webkit-backdrop-filter:none!important;}',
  // Glass elements: remove blur only, keep original background color
  '[data-memory-level="warning"] .glass-effect,[data-memory-level="warning"] .glassmorphism,[data-memory-level="warning"] .glass-surface,[data-memory-level="warning"] .glass-card,[data-memory-level="warning"] .glass-dark,[data-memory-level="warning"] .glass-frosted,[data-memory-level="warning"] .glass-clear,[data-memory-level="warning"] .glass-premium,[data-memory-level="warning"] .glass-light{backdrop-filter:none!important;-webkit-backdrop-filter:none!important;}',
  // === CRITICAL LEVEL: fast animations, no particles, blur-free glass ===
  '[data-memory-level="critical"] *:not(.product-card-premium):not(.badge-shimmer-el):not(.card-shine-sweep):not(.card-image-shine):not(.neon-edge-top):not(.neon-edge-bottom){animation-duration:0.01s!important;transition-duration:0.01s!important;}',
  '[data-memory-level="critical"] .particle-container,[data-memory-level="critical"] .confetti{opacity:0.3!important;animation:none!important;}',
  '[data-memory-level="critical"] .glass-effect,[data-memory-level="critical"] .glassmorphism,[data-memory-level="critical"] .glass-surface,[data-memory-level="critical"] .glass-card{backdrop-filter:none!important;-webkit-backdrop-filter:none!important;}',
  // === EMERGENCY LEVEL: strip expensive GPU effects BUT PRESERVE filter (theming) ===
  // NO filter:none — that flips invert(100%) logos and brightness() themed elements
  // Only strip: animation, transition, box-shadow, backdrop-filter (all layout/GPU-heavy)
  '[data-memory-level="emergency"] *:not(.product-card-premium):not(.badge-shimmer-el):not(.card-shine-sweep):not(.card-image-shine):not(.neon-edge-top):not(.neon-edge-bottom){animation:none!important;transition:none!important;backdrop-filter:none!important;-webkit-backdrop-filter:none!important;}',
  // box-shadow removed separately with a thin border fallback so elements stay visually separated
  '[data-memory-level="emergency"] *:not(.product-card-premium):not(input):not(button):not(a){box-shadow:none!important;}',
  // Emergency glass: remove blur only, preserve original colors
  '[data-memory-level="emergency"] .glass-effect,[data-memory-level="emergency"] .glassmorphism,[data-memory-level="emergency"] .glass-surface,[data-memory-level="emergency"] .glass-card,[data-memory-level="emergency"] .glass-dark,[data-memory-level="emergency"] .glass-frosted,[data-memory-level="emergency"] .glass-clear,[data-memory-level="emergency"] .glass-premium,[data-memory-level="emergency"] .glass-light,[data-memory-level="emergency"] .glass-modal-backdrop{backdrop-filter:none!important;-webkit-backdrop-filter:none!important;}',
  // Emergency media: only strip animation, preserve filter for theming
  '[data-memory-level="emergency"] video{animation:none!important;}',
  '[data-memory-level="emergency"] canvas{image-rendering:optimizeSpeed!important;}',
  '[data-memory-level="emergency"] img{image-rendering:auto!important;}',
  // === LOW-MEMORY-ADAPT class: same approach — opaque bg fallback, keep filter ===
  '.low-memory-adapt *{backdrop-filter:none!important;-webkit-backdrop-filter:none!important;}',
  '.low-memory-adapt .glass-effect,.low-memory-adapt .glassmorphism,.low-memory-adapt .glass-surface,.low-memory-adapt .glass-card{background:inherit!important;border-color:inherit!important;}',
  '.low-memory-adapt video{object-fit:cover;}',
  // NOTE: Removed forced bg-white → black conversion that was causing UI color glitches
  // Glass glow optimization only
  '[data-memory-level] .glass-glow::before,[data-memory-level] .glass-glow-strong::before,[data-memory-level] .glass-glow-pulse::before{display:none!important;}',
  // Preserve filter:invert on logos/icons that need it (explicit safeguard)
  '[data-memory-level] [style*="filter: invert"],[data-memory-level] [style*="filter:invert"]{filter:invert(100%)!important;}',
  '[data-memory-level] .sm-logo-img{filter:inherit!important;}',
  // Mobile full experience
  '.mobile-full-experience [data-desktop-only]{display:block!important;visibility:visible!important;}',
  '.mobile-full-experience [data-hide-mobile]{display:block!important;visibility:visible!important;}',
  '.mobile-full-experience .desktop-only{display:block!important;visibility:visible!important;}',
  '.mobile-full-experience .hidden-mobile{display:block!important;visibility:visible!important;}',
  // Scroll jank fix — no color impact
  '.scroll-janky *{will-change:auto!important;contain:layout style;}',
].join('\n');
d.head.appendChild(memStyle);

// ─── 146-150. Performance.measureUserAgentSpecificMemory (modern API) ───
if(typeof crossOriginIsolated!=='undefined'&&crossOriginIsolated&&p.measureUserAgentSpecificMemory){
  setInterval(function(){
    p.measureUserAgentSpecificMemory().then(function(result){
      MG.preciseMemoryMB=Math.round(result.bytes/1048576);
      if(MG.preciseMemoryMB>budgetMB){
        updateMemoryLevel();
      }
    }).catch(function(){});
  },30000);
}

// ─── 151-155. Page Lifecycle API Integration ───
if('onfreeze' in d){
  d.addEventListener('freeze',function(){
    MG.frozen=true;
    w.dispatchEvent(new CustomEvent('bullmoney-3d-pause'));
    w.dispatchEvent(new CustomEvent('bullmoney-spline-dispose'));
    // v5.0: Run deep clean on freeze (mobile backgrounding)
    deepClean('freeze');
  });
  d.addEventListener('resume',function(){
    MG.frozen=false;
    if(MG.level==='normal'||MG.level==='warning'){
      w.dispatchEvent(new CustomEvent('bullmoney-3d-resume'));
    }
  });
}
// v5.0: Also handle visibilitychange for Safari/Instagram which don't fire freeze
d.addEventListener('visibilitychange',function(){
  if(d.visibilityState==='hidden'){
    // User switched away — aggressively clean up
    deepClean('hidden');
    // Throttle all intervals while hidden
    MG._hiddenTime=Date.now();
  }
  if(d.visibilityState==='visible'&&MG._hiddenTime){
    var away=Date.now()-MG._hiddenTime;
    // If away > 30s, assume memory was reclaimed and re-check level
    if(away>30000)updateMemoryLevel();
    delete MG._hiddenTime;
  }
});

// ════════════════════════════════════════════════════════════════════
// v5.0 NEW: PROACTIVE SLOWDOWN PREVENTION (Opts 156-180)
// These run continuously to prevent the "gets slower over time" problem
// ════════════════════════════════════════════════════════════════════

// ─── 156-158. setInterval/setTimeout Tracker & Reaper ───
// The #1 cause of "page gets slower": leaked intervals that stack on re-renders
var activeIntervals=new Map(); // id → {created, stack, frequency}
var activeTimeouts=new Map();
var origSetInterval=w.setInterval;
var origClearInterval=w.clearInterval;
var origSetTimeout=w.setTimeout;
var origClearTimeout=w.clearTimeout;
var INTERVAL_CAP=isInApp?15:isMobile?25:50;
var TIMEOUT_CAP=isInApp?40:isMobile?80:200;

w.setInterval=function(fn,ms){
  var id=origSetInterval.apply(w,arguments);
  activeIntervals.set(id,{created:Date.now(),ms:ms||0,stack:(new Error()).stack||''});
  MG.activeIntervals=activeIntervals.size;
  // Hard cap: if too many intervals, kill the oldest ones
  if(activeIntervals.size>INTERVAL_CAP){
    pruneStaleTimers(0.4); // Kill 40% of oldest
  }
  return id;
};
w.clearInterval=function(id){
  activeIntervals.delete(id);
  MG.activeIntervals=activeIntervals.size;
  return origClearInterval.call(w,id);
};
w.setTimeout=function(fn,ms){
  var id=origSetTimeout.apply(w,arguments);
  activeTimeouts.set(id,{created:Date.now(),ms:ms||0});
  MG.activeTimeouts=activeTimeouts.size;
  // Auto-remove from tracking when it fires (approx)
  origSetTimeout.call(w,function(){activeTimeouts.delete(id);MG.activeTimeouts=activeTimeouts.size;},(ms||0)+100);
  // Hard cap
  if(activeTimeouts.size>TIMEOUT_CAP){
    var oldest=[];
    activeTimeouts.forEach(function(v,k){oldest.push({id:k,created:v.created});});
    oldest.sort(function(a,b){return a.created-b.created;});
    for(var i=0;i<Math.floor(oldest.length*0.3);i++){
      origClearTimeout.call(w,oldest[i].id);
      activeTimeouts.delete(oldest[i].id);
    }
    MG.activeTimeouts=activeTimeouts.size;
  }
  return id;
};
w.clearTimeout=function(id){
  activeTimeouts.delete(id);
  MG.activeTimeouts=activeTimeouts.size;
  return origClearTimeout.call(w,id);
};

function pruneStaleTimers(killRatio){
  killRatio=killRatio||0.5;
  var list=[];
  activeIntervals.forEach(function(v,k){list.push({id:k,created:v.created,ms:v.ms});});
  if(list.length<=3)return; // Don't kill if only a few
  list.sort(function(a,b){return a.created-b.created;}); // oldest first
  // Kill fast-frequency intervals first (< 1s), then oldest
  list.sort(function(a,b){
    if(a.ms<1000&&b.ms>=1000)return -1;
    if(b.ms<1000&&a.ms>=1000)return 1;
    return a.created-b.created;
  });
  var killCount=Math.max(1,Math.floor(list.length*killRatio));
  // Always keep at least 3 intervals (memory monitor, dom counter, blob checker)
  killCount=Math.min(killCount,list.length-3);
  for(var i=0;i<killCount;i++){
    origClearInterval.call(w,list[i].id);
    activeIntervals.delete(list[i].id);
    MG.disposals++;
  }
  MG.activeIntervals=activeIntervals.size;
  if(w.location.hostname==='localhost'){
    console.warn('[MEMORY GUARDIAN v4] Pruned '+killCount+' stale intervals. Remaining: '+activeIntervals.size);
  }
}

// ─── 159-160. AudioContext Reaper ───
// Multiple components create AudioContext without closing — they accumulate
var trackedAudioCtx=[];
var OrigAudioCtx=w.AudioContext||w.webkitAudioContext;
if(OrigAudioCtx){
  var NewAudioCtx=function AudioContext(){
    var ctx=new OrigAudioCtx();
    trackedAudioCtx.push({ctx:ctx,created:Date.now()});
    MG.audioContexts=trackedAudioCtx.length;
    return ctx;
  };
  NewAudioCtx.prototype=OrigAudioCtx.prototype;
  w.AudioContext=NewAudioCtx;
  if(w.webkitAudioContext)w.webkitAudioContext=NewAudioCtx;
}
function reapAudioContexts(){
  var now=Date.now();
  var reaped=0;
  trackedAudioCtx=trackedAudioCtx.filter(function(entry){
    // Close contexts older than 60s that are suspended or have no active sources
    if(now-entry.created>60000&&entry.ctx.state!=='running'){
      try{entry.ctx.close();}catch(e){}
      reaped++;
      return false;
    }
    // Close ALL contexts older than 5 minutes (aggressive)
    if(now-entry.created>300000){
      try{entry.ctx.close();}catch(e){}
      reaped++;
      return false;
    }
    return true;
  });
  MG.audioContexts=trackedAudioCtx.length;
  if(reaped>0)MG.disposals+=reaped;
}

// ─── 161-163. Detached DOM Node Sweeper ───
// React fast-unmount can leave references; WeakRef-based sweeper helps GC
function sweepDetachedNodes(){
  // Force-null common leak patterns
  var heavySelectors=[
    '.spline-canvas-wrapper canvas',
    '.three-canvas canvas',
    '.ballpit-canvas',
    'canvas[data-engine]',
    'video:not([src])',
    'audio:not([src])',
    'iframe[src="about:blank"]'
  ];
  heavySelectors.forEach(function(sel){
    try{
      d.querySelectorAll(sel).forEach(function(el){
        if(!isElementInView(el)&&!el.closest('[data-keep]')){
          // Remove from DOM to let GC collect
          if(el.tagName==='CANVAS'){
            var ctx2d=el.getContext&&el.getContext('2d');
            if(ctx2d){ctx2d.clearRect(0,0,el.width,el.height);}
            el.width=1;el.height=1; // Release GPU memory
          }
          MG.disposals++;
        }
      });
    }catch(e){}
  });
  // Clear any detached image data
  if(w.createImageBitmap){
    // Hint GC by nulling references
  }
}

// ─── 164-165. History API Memory Cap ───
// SPA navigation can accumulate huge history state objects
var origPushState=history.pushState;
var origReplaceState=history.replaceState;
var historyCount=0;
var MAX_HISTORY=isInApp?20:isMobile?50:100;
history.pushState=function(state,title,url){
  historyCount++;
  // Cap state object size to prevent memory bloat
  if(state&&JSON.stringify(state).length>10000){
    state={_trimmed:true,url:url};
  }
  if(historyCount>MAX_HISTORY){
    // Replace instead of push to prevent unbounded growth
    return origReplaceState.call(history,state,title,url);
  }
  return origPushState.call(history,state,title,url);
};
history.replaceState=function(state,title,url){
  if(state&&JSON.stringify(state).length>10000){
    state={_trimmed:true,url:url};
  }
  return origReplaceState.call(history,state,title,url);
};

// ─── 166-168. Internal Cache Cleaner ───
function clearInternalCaches(){
  // Clear Next.js client-side cache if it's bloated  
  try{
    if(w.__NEXT_DATA__&&w.__NEXT_DATA__.props){
      var pageProps=w.__NEXT_DATA__.props.pageProps;
      if(pageProps&&JSON.stringify(pageProps).length>500000){
        // Trim large page props that React keeps in memory
        Object.keys(pageProps).forEach(function(k){
          if(typeof pageProps[k]==='object'&&pageProps[k]&&JSON.stringify(pageProps[k]).length>50000){
            pageProps[k]=null;
          }
        });
      }
    }
  }catch(e){}
  // Clear image decode cache hints
  try{
    d.querySelectorAll('img').forEach(function(img){
      if(!isElementInView(img)&&img.complete){
        img.decoding='async'; // free synchronous decode memory
      }
    });
  }catch(e){}
  // Purge WeakRef-eligible items by nulling module-level caches
  try{
    if(w.__BM_CACHE__){
      Object.keys(w.__BM_CACHE__).forEach(function(k){
        var c=w.__BM_CACHE__[k];
        if(c&&typeof c==='object'&&Object.keys(c).length>100){
          w.__BM_CACHE__[k]={};
        }
      });
    }
  }catch(e){}
  MG.lastCacheClear=Date.now();
}

// ─── 169-171. Deep Clean (called on pressure / background / timer) ───
var lastDeepClean=0;
var DEEP_CLEAN_COOLDOWN=isInApp?15000:30000; // min ms between deep cleans
function deepClean(reason){
  var now=Date.now();
  if(now-lastDeepClean<DEEP_CLEAN_COOLDOWN)return;
  lastDeepClean=now;
  MG.lastDeepClean={time:now,reason:reason};

  // 1. Prune stale intervals (keep 60%)
  pruneStaleTimers(0.4);
  // 2. Reap AudioContexts
  reapAudioContexts();
  // 3. Sweep detached nodes
  sweepDetachedNodes();
  // 4. Revoke excess blobs
  if(activeBlobs.size>20){
    var count=0;
    activeBlobs.forEach(function(url){
      if(count++<activeBlobs.size-10){
        try{origRevokeURL.call(URL,url);}catch(e){}
        activeBlobs.delete(url);
      }
    });
    MG.activeBlobs=activeBlobs.size;
  }
  // 5. Clear internal caches
  clearInternalCaches();
  // 6. Release off-screen canvases GPU memory
  d.querySelectorAll('canvas').forEach(function(c){
    if(!isElementInView(c)&&!c.closest('[data-keep]')){
      c.width=1;c.height=1;
      MG.disposals++;
    }
  });
  // 7. Clear console (reduces memory in dev tools)
  if(w.location.hostname!=='localhost'){
    try{console.clear();}catch(e){}
  }
  // 8. Hint GC
  try{if(w.gc)w.gc();}catch(e){}
  // 9. Dispatch event so React components can self-clean
  w.dispatchEvent(new CustomEvent('bullmoney-deep-clean',{detail:{reason:reason,level:MG.level}}));

  if(w.location.hostname==='localhost'){
    console.log('%c[MEMORY GUARDIAN v4] Deep clean ('+reason+'). Intervals:'+activeIntervals.size+' AudioCtx:'+trackedAudioCtx.length+' Blobs:'+activeBlobs.size+' DOM:'+MG.domNodes,'color:#f59e0b;font-weight:bold');
  }
}

// ─── 172-174. Progressive Degradation Timeline ───
// As session length increases, proactively reduce overhead
var sessionStart=Date.now();
setInterval(function(){
  var sessionMinutes=Math.floor((Date.now()-sessionStart)/60000);
  MG.sessionMinutes=sessionMinutes;

  // After 2 min on mobile/in-app: first cleanup pass
  if(sessionMinutes>=2&&!MG._cleaned2){
    MG._cleaned2=true;
    deepClean('session-2m');
  }
  // After 5 min: more aggressive
  if(sessionMinutes>=5&&!MG._cleaned5){
    MG._cleaned5=true;
    deepClean('session-5m');
    // Force warning level on in-app browsers after 5 min
    if(isInApp&&MG.level==='normal'){
      MG.level='warning';
      d.documentElement.setAttribute('data-memory-level','warning');
    }
  }
  // After 10 min: heavy cleanup every 2 min from now on
  if(sessionMinutes>=10&&sessionMinutes%2===0){
    deepClean('session-periodic-'+sessionMinutes+'m');
  }
  // After 15 min on in-app: critical mode
  if(sessionMinutes>=15&&isInApp&&MG.level!=='emergency'){
    MG.level='critical';
    d.documentElement.setAttribute('data-memory-level','critical');
    executeMemoryRelief('critical');
  }
},60000);

// ─── 175-176. requestAnimationFrame Overload Prevention ───
// Detect RAF storms (multiple components running RAF loops)
var rafCount=0;
var rafResetTime=Date.now();
var origRAF=w.requestAnimationFrame;
var RAF_CAP_PER_SEC=isInApp?30:isMobile?45:120;
w.requestAnimationFrame=function(cb){
  var now=Date.now();
  if(now-rafResetTime>1000){
    // If RAF count was absurdly high, we have RAF storms
    if(rafCount>RAF_CAP_PER_SEC*2){
      MG.rafStorm=true;
      if(w.location.hostname==='localhost'){
        console.warn('[MEMORY GUARDIAN v4] RAF storm detected: '+rafCount+'/sec. Throttling.');
      }
      // Throttle: skip every other frame
      var skip=false;
      var throttledRAF=origRAF;
      w.requestAnimationFrame=function(cb2){
        skip=!skip;
        if(skip&&MG.rafStorm)return 0;
        return throttledRAF.call(w,cb2);
      };
    }
    rafCount=0;
    rafResetTime=now;
  }
  rafCount++;
  return origRAF.call(w,cb);
};

// ─── 177-178. createElement Tracking (detect DOM node factories) ───
var createdElements=0;
var lastCreateReset=Date.now();
var origCreateElement=d.createElement.bind(d);
var CREATE_CAP_PER_SEC=isInApp?30:isMobile?60:200;
d.createElement=function(tag){
  var el=origCreateElement(tag);
  createdElements++;
  var now=Date.now();
  if(now-lastCreateReset>5000){
    if(createdElements>CREATE_CAP_PER_SEC*5){
      // Creating too many elements too fast — likely a leak or particle system gone wild
      if(w.location.hostname==='localhost'){
        console.warn('[MEMORY GUARDIAN v4] Rapid DOM creation: '+createdElements+' in 5s');
      }
      deepClean('rapid-dom-create');
    }
    createdElements=0;lastCreateReset=now;
  }
  return el;
};

// ─── 179. Stale Component Detector ───
// React components that haven't been interacted with for a while can self-dispose
MG.componentActivity={};
MG.reportComponentActivity=function(id){
  MG.componentActivity[id]=Date.now();
};
MG.getStaleComponents=function(maxAgeMs){
  maxAgeMs=maxAgeMs||120000; // 2 min default
  var now=Date.now();
  var stale=[];
  Object.keys(MG.componentActivity).forEach(function(id){
    if(now-MG.componentActivity[id]>maxAgeMs)stale.push(id);
  });
  return stale;
};

// ─── 180. Startup: immediate assessment for in-app/mobile ───
// Don't wait for gradual detection — start in warning mode on constrained browsers
if(isInApp||deviceMem<=2){
  MG.level='warning';
  d.documentElement.setAttribute('data-memory-level','warning');
  d.documentElement.classList.add('low-memory-adapt');
  // Tighter budgets: run first deep clean after 30s
  origSetTimeout.call(w,function(){deepClean('startup-inapp');},30000);
}

d.documentElement.setAttribute('data-memory-level',MG.level);
d.documentElement.setAttribute('data-memory-budget',budgetMB);
d.documentElement.setAttribute('data-memory-guardian-version','4.0');

if(w.location.hostname==='localhost'){
  console.log('%c[MEMORY GUARDIAN v4] Active | Budget:'+budgetMB+'MB | Device:'+deviceMem+'GB | InApp:'+isInApp+' | Mobile:'+isMobile+' | Safari:'+isSafari+' | Check:'+checkInterval+'ms | Caps: intervals='+INTERVAL_CAP+' timeouts='+TIMEOUT_CAP+' listeners='+LISTENER_CAP+' dom='+DOM_NODE_HARD_CAP+' raf/s='+RAF_CAP_PER_SEC,'color:#22c55e;font-weight:bold');
}
})();